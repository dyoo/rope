_rope.ss_: Ropes for fast string concatenation and subsequencing

Danny Yoo (dyoo@cs.wpi.edu / dyoo@hkn.eecs.berkeley.edu)

Index terms: _ropes_


Introduction
============

This presents a _rope_ data structure which is very much like a
string, except that it provides constant-time concatenation, as well
as inexpensive subsequencing.  It's pretty much what's described in
the paper "Ropes: an Alternative to Strings" by Boehm, Atkinson, and
Plauss.


Example
=======

     > (require (planet "rope.ss" ("dyoo" "rope.plt" 2)))
     > (define a-rope
         (rope-append 
          (string->rope 
           "hello, this is a test of the emergency broadcast")
          (string->rope "system; this is only a test")))
     > a-rope
     > #<struct:rope:concat>

     > (rope-length a-rope)
     75
     
      > (subrope a-rope 5)
      #<struct:rope:concat>
      > (rope->string (subrope a-rope 5 10))
      ", thi"
      > (rope-ref (subrope a-rope 20) 0)
      #\t


API
===

A rope is defined to be either:

   * A string node,
   * A special node, or
   * A concatenation node made of a left rope and a right rope.

Use string->rope and special->rope to convert those types to
their respective rope values.  Concatenation nodes are built
with rope-append.


> rope?: any -> boolean

Returns true if the input is a rope.


> rope-append: rope rope -> rope

Joins two ropes together in constant time.


> rope-length: rope -> natural-number

Returns the length of a rope.


> rope-ref: rope natural -> char

Returns the nth character of a rope.


> subrope: rope start [end] -> rope

Returns a subsequence of the rope containing all the character from
start up to (but not including) the end.  If the end is not provided,
then the subrope extends to the end of the rope.


> rope->string: rope -> string

Creates a string from the content in the rope.

NOTE: if the rope contains special nodes, this function will raise an error.


> string->rope: string -> rope

Given a long string, breaks it up into smaller rope fragments and appends
them all together.  The resulting rope is balanced.


> special->rope: any -> rope

Creates a rope element of length one whose content is the given element.


> rope-for-each: (char-or-special -> void) rope [start] -> void

Applies the input function on every character or special in the rope, starting
from the start index (which defaults to zero.)


> rope-fold: (char-or-special X) X rope [start] -> X

Folds an accumulating function across every character or special in the rope,
starting from the start index (which defaults to zero.)


> rope-fold/leaves: (immutable-string-or-special X) X rope [start] -> X

Folds an accumulating function across every chunk of string or special in the rope,
starting from the start index (which defaults to zero.)


> open-input-rope: rope -> input-port

Returns an input port whose byte content comes from the rope.
(FIXME: how do we accomodate specials?)


Other API functions
===================


> rope-depth: rope -> natural-number

Returns the depth of the rope data structure.


> rope-count-nodes: rope -> natural-number

Returns the number of nodes in the rope.


> rope-balance: rope -> rope

Returns a balanced version of the rope with logarithmic height.




Notes
=====

Unlike the description in the paper, this library does not
automatically rebalance the data structure when applying subrope or
rope-append.  Explicit rebalancing may improve the performance of subsequencing and referenceing
on the rebalanced tree.

All operations are done without mutation.



Recent changes
==============

2007/09/01: library API extended to support "special" objects.



References
==========

Hans-Juergen Boehm and Russell R. Atkinson and Michael F. Plass.
"Ropes: an Alternative to Strings."  Software - Practice and
Experience, Volume 25, No. 12.  pp 1315--1330.  (1995).
